8.1.1 The test are passing. The current test method is covering all methods as far as I can see,  but it is done in a very unstructured way. However, we do not test that the resize function works as expected for the stripedWriteMap as it is done internally, but this is also quite difficult to test without altering the code. I have written a new version of testMap which I believe covers all paths and is more structured.
8.1.2 I have implemented a Concurrent Test method. I did not find any defects in my code. I'm quite convinced about the correctness of the code, however, because there are so many possible interleavings there could be an undiscovered concurrency issue. I'm not sure what the test tells me about containsKey. I implemented my tests not to depend on the result of containsKey because the operation of checking containsKey and the doing another operation is not atomic, and could therefore interleave with another thread. For example if containsKey for key k return false and the code continues to put the key into the map, it will not increase the size counter until it is confirmed that the key was not in the map as the key could have been added in between the operations. 
8.1.3 The tests passed
8.1.4 See the code
8.1.5 See the code
8.1.6 On the top my head I have no further improvements as this is already super cool!

8.2.1 When removing the synchronization in the put implementation the test fails
8.2.2 When changing the lock to synchronized(locks[0]) the test fails. When changing the lock to synchronized(this) the test does not fails. This is expected as these changes lead to incorrect code resulting in race conditions which is successfully detected by the tests 
8.2.3 I ran the tests 10 times, but they do not break due to the changes. After carefully going through the code, this is due to the fact the we only test on the methods put, putIfAbsent, remove and containsKey. In the three first all access to sizes are done while having a stripe lock, and as only the element in the size array belonging to the stipe is the only one being accessed, there is no incorrect concurrent access to sizes. containsKey accesses sizes in a troublesome way as it does not have a lock and because the value is not volatile. This could cause problems, but because of my tests not depending on the result of containsKey (as mentioned previously, no problems in regards to the test being run occurs.
8.2.4 I removed the sizes read operations in get and containsKey, which results visibility not being guaranteed, but it is not breaking the tests. 
8.2.5 Faults in the least used methods might occur more rarely. Fx when we only use a keyspace on 100 and an initial bucketsize of 77 where we will only have to reallocate once during the whole test. Therefore faults in the reallocation might not occur during the test.

