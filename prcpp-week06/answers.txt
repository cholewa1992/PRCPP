6.1.[1,3-4] See the code.
6.1.2 It is important to synchronize both due to visibility and because we don't want a reallocateBuckets to happened while summing the size.
6.1.5 I have implemented a stripe wise version. This requires less locking and therefore can result in better performance. This version might return a size that in the meantime has changed - This is acceptable in concurrent code. The other version locking all stripes before entering would ensure that the size returns in the guaranteed current size of the HashMap, but as I don't see a need for this, I choose the stripe wise version.
6.1.6 See TestStripedMap616.txt
6.1.7 See TestStripedMap617.txt. The striped map is clearly faster than the synchronized map which was expected as the synchronized map as the SyncMap can only perform one concurrent operation at a time. The StripMap can perform 32 (as lock count is set to 32) operations concurrently.
6.1.8 It is a good idea to keep the number of stripes low as the length of buckets must be mod lockCount equals 0. Another reason is that the size and forEach method will take longer time the more stripes we have and lastly because more stripes we have to more overhead memory will be used to maintaining the map.
6.1.9 If the number of stripes is to low we will not fully utilize the performance capacity of the implementation. This is due to that facts that we can only do as many things in parallel as there is strips. If we have 16 threads and 16 stripes, some stripes might still be blocked because they try to access bins that is guarded by the same lock, and therefore blocking multiple threads with a single lock. Having more stripes, and thereby more locks, this becomes less frequent.
6.1.10 Because h % lockCount must be an invariant during bucketDoubling. Otherwise we can wait for a lock for h % lockCount, meanwhile a bucketDoubling is happening, and we then acquire a lock for a different bucket than the one we write to.
6.2.[1,3,4] See the code
6.2.2 Because nothing changed if nothing was added. Therefore no need for visibility guarantee.
6.2.5 See TestStripedMap625.txt. The results are as expected as WriteStriped map is clearly the fastest compared to the other two maps we implemented. The exerciseMap method is mostly using containsKey and sometimes put and rarely remove and putIfAnset. The containsKey is, compared to the two other maps, no longer blocking resulting in the speedup. If the ratio was different, the results might also be very different, as I expect the WriteStripedMap to perform poorly with many deletes due to its immutable nature.
6.3.1 See TestLongAdder.xlsx and TestLongAdder.txt. From the graph it clearly shows how the different implementations scale. The synchronized longCounter is as expected the slowest, this was expected as only one thread can add at the same time making the implementation thread-safe, but very slow. The other implementations are stripes in a way so that multiple threads can write at the same time, and that reflects in their performance.
6.3.2 As seen in the graph the object allocations did not improve performance on my hardware.



