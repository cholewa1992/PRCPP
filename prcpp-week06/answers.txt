6.1.[1,3-4] See the code.
6.1.2 It is important to synchronise both due to visibility and because we don’t want a reallocateBuckets to happened while summing the size.
6.1.5 I have implemented a stripe wise version. This requires less locking and therefore can result in better performance. This version might return a size that in the meantime has changed - This is acceptable in concurrent code. The other version locking all stripes before entering would ensure that the size returns in the guaranteed current size of the HashMap, but as I don’t see a need for this, I choose the stripe wise version.
6.1.6 See TestStripedMap616.txt
6.1.7 See TestStripedMap617.txt. The striped map is clearly faster than the synchronised map which was expected as the synchronised map as the SyncMap can only perform one concurrent operation at a time. The StripMap can perform 32 (as lock count is set to 32) operations concurrently.
6.1.8 It is a good idea to keep the number of stripes low as the length of buckets must be mod lockCount equals 0. Another reason is that the size and forEach method will take longer time the more stripes we have and lastly because more stripes we have to more overhead memory will be used to maintaining the map.
6.1.9 If the number of stripes is to low we will not fully utilise the performance capacity of the implementation. This is due to that facts that we can only do as many things in parallel as there is strips. If we have 16 threads and 16 stripes, some stripes might still be blocked because they try to access bins that is guarded by the same lock, and therefore blocking multiple threads with a single lock. Having more stripes, and thereby more locks, this becomes less frequent.
6.1.10 Because h % lockCount must be an invariant during bucketDoubling. Otherwise we can wait for a lock for h % lockCount, meanwhile a bucketDoubling is happening, and we then acquire a lock for a different bucket than the one we write to.
6.2.1 